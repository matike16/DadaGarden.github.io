---
title: 中级软考-软件设计师
icon: feather
date: 2024-08-26
category: 知识快学
tags:
  - 软考
cover: /assets/images/软件考试.jpg
excerpt: 软考，即中国计算机技术职业资格考试，是评估计算机技术专业人员专业水平和职业能力的国家级考试。
order: "6"
---

> [!tip]
> 以中级软设为介绍

## 关于软考

- 软考对于不同级别没有硬性要求，可以按需选择初中高级进行考取
- 初中高级考试伴随着等级的不断深入对于代码编写的需求反而降低，越往上考察的越是对算法和框架知识的认识。
- 考试采用机考形式、其中填空题多为客观题型，而非主观问答。考试的核心关注点多在于科目的内容差异。

### 考试目的

- 获取职称：以考代评
- 国际意义：中日韩互认
- 政府项目投标
- 申请评标专家入政府专家库
- 技能补贴&补个税【继续教育类别按照3600元定额扣除】
- 升职加薪，扩展就业方向
- 为高级科目【系分&架构】考试做准备

::: important 主要作用
以考代学，激励个人学习热情，提供目的性。
:::

### 考试流程

- 报名-支持线上/线下报名
- 缴费-支持线上/线下缴费
- 打印准考证-考前一周左右
- 参加考试-带齐资料，准时参加考试
- 查询成绩-考试结束后45-60天
- 领取证书-关注各省份具体通知

### 考试时间

一般分为上下半年：上半年5月中下旬，下半年11月中旬。2024年下半年考试时间为11月9日至12日。

部分资格证会存在一年只考一次的情况，要仔细阅读官方发送的考试指南和时间。

### 考核标准

一般情况所有科目达到45分合格

### 综合知识+案例分析

1. 综合知识客观题：75空
	- 考试时间：120分钟
	- 满分75分
2. 软件设计主观题：6道大题（只做5道）
	- 考试时间：120分钟
	- 满分75分
	- 前四道必答，后2道二选一（JAVA或C++）

#### 综合知识（上午综合题）


|   知识点    | 分数  |                                             说明                                              |   比例   |
| :------: | :-: | :-----------------------------------------------------------------------------------------: | :----: |
|  软件工程基础  | 13  |               开发方法与开发模型、数据流图与数据字典、结构化设计、测试方法与McCabe环路复杂度、软件维护、质量特征、CMM、Pert图                | 17.33% |
|   面向对象   | 11  |                                 面向对象基本概念、面向对象分析与设计、UML、设计模式                                 | 14.67% |
| 数据结构与算法  |  9  | 数组、顺序表与链表、队列与栈、字符串、二叉树的存储与特性、二叉树遍历、排序二叉树、最优二叉树、图的概念与存储、图的遍历、图的拓扑排序、二分查找、哈希查找、常见的排序算法、常见算法策略 |  12%   |
|  程序设计语言  |  6  |                    各种程序语言的特点比较、编译与解释、编译器处理过程、错误管理、传值与传址、有限自动机、正规式、后缀表达式                     | 8.00%  |
| 计算机硬件基础  |  6  |              数据的表示、CPU组成、CISC与RISC、流水线技术、层次化存储、I/O数据传输控制方式、可靠性方式、校验方法、计算机性能指标               | 8.00%  |
|   操作系统   |  6  |                      信息量与PV操作、死锁问题、段页式存储、磁盘调度、文件管理（索引文件结构、位视图与树形目录结构）                       | 8.00%  |
|  数据库系统   |  6  |                      E-R模型、关系代数和SQL查询语句、规范化理论（键、范式、模式分析）、并发控制、分布式数据库特点                      | 8.00%  |
|  计算机网络   |  5  |                              OSI模型、TCP/IP协议簇、子网划分、常用的网络命令、URL                               | 6.67%  |
|  信息安全知识  |  5  |                 加密/解密技术、数字签名与信息摘要、数字证书、网络安全协议、常见的网络威胁、常见的网络安全控制方式、网络安全防范体系                  | 6.67%  |
| 知识产权与标准化 |  3  |                                知识产权保护对象和范围、保护期限、知识产权归属、侵权判定                                 | 4.00%  |
|   专业英语   |  5  |                                           专业英语填空                                            | 6.67%  |

>[!tip]
>可以提前30分钟交卷

#### 软件设计（下午主观题）

| 题号  | 试题类型 |   学科知识点    |                           考察内容                           |
| :-: | :--: | :--------: | :------------------------------------------------------: |
| 试题1 | 必答题  |   数据流程图    | 给出相应名称（补充外部实体、补充数据存储、补充加工），补充数据流图的确实部分（补充数据流），数据流图相关解答题。 |
| 试题2 | 必答题  |   流程图设计    |               E-R模型、关系模式、主键/外键、规范化理论、增加实体等               |
| 试题3 | 必答题  |   UML建模    |                  类图、用例图、活动图、状态图等补充图示的缺失                  |
| 试题4 | 必答题  |   C语言算法    |                 分治法、贪心法、动态规划法、回溯法等算法策略应用                 |
| 试题5 | 选答题  | C++语言程序设计  |                       C++语法 + 设计模式                       |
| 试题6 | 选答题  | Java语言程序设计 |                      Java语法 + 设计模式                       |
> [!warning]
> 每道题不要超过25分钟

>[!tip]
>1. 要看得懂代码
>2. 了解各语言语法结构

### 备考策略

- 高质量的备考资料--自收集整理
- 高效的备考方式
	- 基础阶段：大面积撒网（60%）略读->做题->回顾->精度，每章小迭代，一轮迭代一般1个月至一个半月，最多不超过2个月。
	- 积累阶段：有针对性的突破（30%）完成所有章节之后，进行真题测试，测试回顾，分析弱点，再到章节走小迭代。
	- 冲刺阶段：全过程回顾（10%）对已练习的知识点进行梳理，对以前的错题进行回顾，巩固加深。

#### 刷题策略

1. 知识点练习题
2. 章节练习题
3. 真题
4. 模拟题
5. 冲刺题

#### 确定备考计划

1. 全程计划
2. 月计划
3. 周计划
4. 日计划

> [!important]
> - 构造自己的思维导图
> - ”二八定律“，将时间用在重点上
> - 各个击破，混合训练
> - 不要眼高手低，也不要畏难退缩，一定要动手练习

## 一、数据的表示

- 考点1：进制转换
- 考点2：码制（原码/反码/补码/移码）
- 考点3：浮点数的表示
- 考点4：逻辑运算

### 考点1：进制转换

|   进制    |         数码          | 基数  |   位权   |
| :-----: | :-----------------: | :-: | :----: |
| 十进制(D)  | 0,1,2,3,4,5,6,7,8,9 | 10  | $10^k$ |
| 二进制(B)  |         0,1         |  2  | $2^k$  |
| 十六进制(H) |   0-9,A,B,C,D,E,F   | 16  | $16^k$ |
>[!tip]
>十六进制中，字母表示：
>- A 表示 10
>- B 表示 11
>- C 表示 12
>- D 表示 13
>- E 表示 14
>- F 表示 15

#### ==按权展开法==

R进制转十进制使用按权展开法，其具体操作方式为：将R进制数的每一位数值用 $R^k$ 形式表示，即幂的底数是R，指数为k，k与该位和小数点之间的距离有关。当该位位于小数点左边，k值是该位和小数点之间数码的个数，而当该位位于小数点右边，k值是负值，其绝对值是该位和小数点之间数码的个数加1。

例如二进制：

$10100.01 = 1 \times 2^{4} + 1 \times 2^{2} + 1 \times 2^{-2}$

例如七进制：

$604.01 = 6 \times 7^{2} + 4 \times 7^{0} + 1 \times 7^{-2}$

#### ==短除法==

十进制转R进制使用短除法（除基取余法）。

例如将94转换为二进制

1. 将94除以2，得到商47和余数0。
2. 将47除以2，得到商23和余数1。
3. 将23除以2，得到商11和余数1。
4. 将11除以2，得到商5和余数1。
5. 将5除以2，得到商2和余数1。
6. 将2除以2，得到商1和余数0。
7. 最后，1除以2，得到商0和余数1。

现在，我们将这些余数从下到上读出来，即得到94的二进制表示：1011110。

若将94转换为十六进制

1. 将94除以16，得到商5和余数14。
	- 在十六进制中，数字10到15分别用字母A到F表示，所以余数14用字母"E"表示。
2. 将商5保留，因为它小于16，不需要进一步转换。

因此，十进制数94转换为十六进制数是5E。

#### ==减法==

十进制转二进制使用减法。

记忆内容：

- $2^0=1$
- $2^1=2$
- $2^2=4$
- $2^3=8$
- $2^4=16$
- $2^5=32$
- $2^6=64$
- $2^7=128$
- $2^8=256$
- $2^9=512$
- $2^{10}=1024$

以94为例：

- 小于且离94最近的乘幂为64
	- 94-64=30（2的6次方）
- 小于且离30最近的乘幂为16
	- 30-16=14（2的4次方）
- 小于且离14最近的乘幂为8
	- 14-8=6（2的3次方）
- 小于且离6最近的乘幂为4
	- 6-4=2（2的2次方）
- 小于且离2最近的乘幂为2
	- 2-2=0（2的1次方）
- 结束

将出现的位权记为1，即出现过的几次方，几的位置就为1。

| 位号  | 6   | 5   | 4   | 3   | 2   | 1   | 0   |
| --- | --- | --- | --- | --- | --- | --- | --- |
| 位值  | 1   | 0   | 1   | 1   | 1   | 1   | 0   |

最后结果为位值：1011110

#### ==进制转换==

二进制转八进制与十六进制

##### 二进制转换为八进制

1. **分组**：从二进制数的最低位开始，将二进制数每3位分为一组。如果二进制数的位数不是3的倍数，可以在最左边补0以补足3位。
2. **转换**：将每组3位二进制数转换为对应的八进制数。二进制的000到111分别对应八进制的0到7。

##### 二进制转换为十六进制

1. **分组**：从二进制数的最低位开始，将二进制数每4位分为一组。如果二进制数的位数不是4的倍数，可以在最左边补0以补足4位。
2. **转换**：将每组4位二进制数转换为对应的十六进制数。二进制的0000到1111分别对应十六进制的0到F。

##### 示例

假设我们有一个二进制数`1011011`，我们分别转换为八进制和十六进制：

- **转换为八进制**：
    
    1. 分组：001 011 011（在最左边补两个0）
    2. 转换：001（1）011（3）011（3）
    3. 结果：133

- **转换为十六进制**：
    
    1. 分组：0101 1011
    2. 转换：0101（5）, 1011（B）
    3. 结果：5B

这样，二进制数`1011011`转换为八进制是`551`，转换为十六进制是`5B`。

### 考点2：码制

#### 原码/反码/补码/移码

假设固定读取长度为8位：

|     |    数值1    |   数值-1    |    1-1    |
| :-: | :-------: | :-------: | :-------: |
| 原码  | 0000 0001 | 1000 0001 | 1000 0010 |
| 反码  | 0000 0001 | 1111 1110 | 1111 1111 |
| 补码  | 0000 0001 | 1111 1111 | 0000 0000 |
| 移码  | 1000 0001 | 0111 1111 | 1000 0000 |
- 原码：最高位是符号位，其余低位表示数值的绝对值
- 反码：正数的反码与原码相同，负数的反码是其绝对值按位取反（符号位不变）
- 补码：正数的补码与原码相同，负数的补码是其反码末位加1（符号位不变）
- 移码：补码的符号位按位取反

::: important 补充
1. 原码：
	- 原码是最直接的二进制表示，用于表示有符号的整数。
	- 原码的第一位是符号位，其中0表示正数，1表示负数。
	- 剩下的位表示数值的大小。
2. 反码：
	- 反码主要用于二进制的算术运算，特别是减法。
	- 对于正数，反码与其原码相同。
	- 对于负数，反码是其原码除符号位外的所有位取反（0变1，1变0）
3. 补码：
	- 补码同样用于二进制的算数运算，特别是加法和减法。
	- 对于正数，补码与其原码相同。
	- 对于负数，补码是其反码加1。这使得负数的加法运算可以通过正数的加法运算实现。
4. 移码：
	- 移码是一种特殊的编码方式，通常用于浮点数的指数部分。
	- 移码的目的是将偏移量（bias）加到实际的指数上，以简化浮点数的运算。
	- 移码的计算方法是将指数加到一个固定的偏移量，然后转换位二进制。
:::

::: tip 码制的应用
在计算机中，补码是最常用的二进制编码方式，因为它简化了计算机的硬件设计，使得加法和减法可以使用相同的电路来实现。例如，当你想计算一个负数的补码时，你只需要将这个负数的原码转换为反码，然后加1即可得到补码。在实际的计算机系统中，数值的存储和运算都是基于补码，这样可以避免额外的硬件逻辑来处理正负数的区分。
:::

#### 定点整数/定点小数/数码个数

| 码制  |             定点整数              |                定点小数                 |  数码个数   |
| :-: | :---------------------------: | :---------------------------------: | :-----: |
| 原码  | $-(2^{n-1}-1)$~$+(2^{n-1}-1)$ | $-(1-2^{-(n-1)})$~$+(1-2^{-(n-1)})$ | $2^n-1$ |
| 反码  | $-(2^{n-1}-1)$~$+(2^{n-1}-1)$ | $-(1-2^{-(n-1)})$~$+(1-2^{-(n-1)})$ | $2^n-1$ |
| 补码  |   $-2^{n-1}$~$+(2^{n-1}-1)$   |        -1~$+(1-2^{-(n-1)})$         |  $2^n$  |
| 移码  |   $-2^{n-1}$~$+(2^{n-1}-1)$   |        -1~$+(1-2^{-(n-1)})$         |  $2^n$  |

**定点整数**

当n=8，也就是一共8个数位时：

- 原码：$-(2^{n-1}-1)$~$+(2^{n-1}-1)$
	- -127~+127
- 转为二进制
	- 1111 1111 ~ 0111 1111

- 补码：
	- 1000 0000 ~ 0111 1111
	- 其中-128的补码为1000 0000是认为规定。

**定点小数**

当n=8，也就是一共8个数位时：

- 原码：$-(1-2^{-(n-1)})$~$+(1-2^{-(n-1)})$
	- -0.1111111 ~ +0.1111111

- 补码：
	- -1 ~ +0.1111111
	- 其中-1的补码为1000 00.00是人为规定。

::: important 定义补充
在数字系统中，数据可以以不同的格式存储，其中两种常见的格式是定点数和浮点数。

1. 定点整数：
	- 定点整数是指小数点固定在某个位置的整数。在计算机中，整数通常以定点形式存储，小数通常被假设在最右边的数字之后。
	- 例如，如果我们有一个8位的二进制数01010101，它可以表示为定点整数85（十进制）。
2. 定点小数：
	- 定点小数是指小数点固定在某个位置的小数。在计算机中，定点小数通常用于需要精确小数运算的场合，如金融运算。
	- 定点小数的表示方式是将小数点固定在数字的某个位置，然后按照这个固定的位置来存储数字。例如，如果我们有一个定点小数1.25，并且我们决定小数点后面保留两位小数，那么在二进制中，它可能表示为0.101（这里假设我们使用3为来表示整数部分，2位来表示小数部分）。

在实际的计算机系统中，定点数的表示通常涉及到位数的分配，即决定多少位用于表示整数部分，多少位用于表示小数部分。这种分配方式会影响到数值的精度和范围。

与定点数相对的是浮点数，浮点数的表示方式允许小数点的位置变动，这样可以表示更大范围的数值，但通常会牺牲一些精度。浮点数的表示遵循特定的标准，如IEEE 754标准。
:::

#### 例题

::: tip 例题1
采用n位补码（包含一个符号位）表示数据，可以==直接表示数值==（）。
- A、$2^n$
- B、$-2^n$
- C、$2^{n-1}$
- D、$-2^{n-1}$
:::

==法一：==

根据公式可知：
- 补码的定点整数范围
	- $-2^{n-1}$~$+(2^{n-1}-1)$
- 补码的定点小数范围
	- -1~$+(1-2^{-(n-1)})$

- 根据范围可知可以直接表示的数值为$-2^{n-1}$

==法二：==

假设n=4（4位补码），我们来分析每个选项：

- 选项A: $2^n$
	- 当n=4时，$2^n$=16
	- 4位补码的最大正数是  $2^{4-1}-1$ = 15
	- 因此，$2^n$（16）超出了4位补码的表示范围。

- 选项B: $-2^n$
	- 当n=4时，$-2^n=-16$
	- 4位补码的最小负数是 $-2^{4-1}=-8$
	- 因此，$-2^n$（-16）超出了4位补码的表示范围。

- 选项C: $2^{n-1}$
	- 当n=4时，$2^{n-1}=2^3=8$
	- 4位补码的最大正数是 $2^{4-1}-1$ = 15
	- 因此，$2^{n-1}$（8）在4位补码的表示范围内，但不是直接表示的数值。

- 选项D: $-2^{n-1}$
	- 当n=4时，$-2^{n-1}=-8$
	- 4位补码的最小负数是 $-2^{4-1}=-8$
	- 因此，$-2^{n-1}$（-8）是4位补码可以直接表示的最小负数。

通过代入n=4的具体值，我们可以看到：

- 选项A和B的值都超出了4位补码的表示范围。
- 选项C的值虽然在范围内，但不是直接表示的最小或最大值。
- 选项D的值是4位补码可以直接表示的最小负数。

因此，正确答案是 **D、$-2^{n-1}$**。

::: tip 例题2
如果“2X”的补码是“90H”，那么X的真值是（）。
- A、72
- B、-56
- C、56
- D、111
:::

- 先将 90H（十六进制）转换为二进制
	- 90 按权展开为十进制得到 $9\times16=144$
	- 144 转二进制使用短除法得到1001 0000
- 现在得到了补码形式的 1001 0000，所谓真值指的就是求原码形式的十进制。
	- 若是正数，原码/反码/补码都相同。
	- 若是负数，原码符号位不变，其他位按位取反得到反码，反码通过末位加1得到补码。
	- 反向推导，1001 0000 先减一得到反码：1000 1111
	- 反码 1000 1111 符号位不变，其余位按位取反得到原码：1111 0000
- 最后1111 0000 转换为十进制
	- 注意最高位（最右侧位）为符号位，1代表负号，0代表正号。
	- 所以，数值位应该位0111 0000，转为十进制为：32+16+8 = 56
	- 带上符号位得到结果：-56
- 最终结果为-56

故最终答案为**D、-56**。

### 考点3：浮点数的表示

#### ==浮点的运算==

**浮点数的表示：**

$N=尾数\times基数^{指数}$

- 尾数
	- ==定点小数==表示，小数点前保留一位数
	- 一般用==补码==表示
	- IEEE 754标准中可以用原码表示
	- 尾数可以表示数值的有效精度，长度越大，位数越多，表示精度越高
- 指数
	- 又称阶码
	- 一般为==定点整数===
	- 用==移码==表示
	- 可以用来决定数的表示范围，位数越多范围越大
- 基数
	- 在计算机当中是不需要存储的


**运算过程：**

对阶>尾数计算>结果格式化

- 对阶时，小数向大数看齐
- 对阶是通过较小数的尾数右移实现的

#### ==例题==

::: tip 例题1
浮点数能够表示的数的范围是由其（）的位数决定的。
- A、尾数
- B、阶码
- C、数符
- D、阶符
:::

正确答案：**B、阶码**

::: important 选项概念补充
- **数符**：数符是浮点数表示中的一个位，用来表示数值的正负。通常，0表示正数，1表示负数。数符并不决定数值的范围，它只影响数值的符号。
- **阶符**：在标准的浮点数表示中，如IEEE 754，并没有单独的“阶符”这个概念。阶码部分通常包含一个符号位，但这个位是通过偏移量（bias）来实现正负指数的表示，而不是直接表示为一个单独的符号位。因此，这个选项在标准的浮点数表示中是不适用的。
:::

::: tip 例题2
以下关于两个浮点数相加运算的叙述中，正确的是（）
- A、首先进行对阶，阶码大的向阶码小的对齐
- B、首先进行对阶，阶码小的向阶码大的对齐
- C、不需要对阶，直接将尾数相加
- D、不需要对阶，直接将阶码相加
:::

正确答案：**B**

此题考查运算步骤不做详细解释。

::: tip 例题3
设16位浮点数，其中阶符1位、阶码值6位、数符1位、尾数8位。若阶码用移码表示，尾数用补码表示，则该浮点数所能表示的数值范围是（）
- A、$-2^{64}$~$(1-2^{-8})2^{64}$
- B、$-2^{63}$~$(1-2^{-8})2^{63}$
- C、$-(1-2^{-8})2^{64}$~$(1-2^{-8})2^{64}$
- D、$-(1-2^{-8})2^{63}$~$(1-2^{-8})2^{63}$
:::

- 浮点数表示公式：$N=尾数\times基数^{指数}$

- 首先根据题意我们可以绘制一个16位的表格

<table>
  <tr>
    <th>阶符</th>
    <th colspan="6">阶码（6位）</th>
    <th>数符</th>
    <th colspan="8">尾数（8位）</th>
  </tr>
  <tr>
    <td> </td>
    <td> </td>
    <td> </td>
    <td> </td>
    <td> </td>
    <td> </td>
    <td> </td>
    <td> </td>
    <td> </td>
    <td> </td>
    <td> </td>
    <td> </td>
    <td> </td>
    <td> </td>
    <td></td>
    <td> </td>
  </tr>
</table>

- 阶码（定点整数）：n=7，移码表示范围？
	- $-2^{n-1}$~$+(2^{n-1}-1)$
	- $-64$~$63$
	- 由此可知指数可以取$-64$~$63$范围的值，排除A和B选项。
- 尾数（定点小数）：n=9，补码表示范围？
	- -1~$+(1-2^{-(n-1)})$
	- -1~$+(1-2^{-8})$
	- 根据B、D选项可知，只需要判断最小的范围即可，很明显，B选项的范围包括了D选项且可以取到。
- 因此最终答案为**B**

### 考点4：逻辑运算

#### ==关系运算符==

**关系运算符及其优先次序**

- 优先级相同（高）
	- < （小于）
	- <= （小于或等于）
	- > （大于）
	- >= （大于或等于）
- 优先级相同（低）
	- == （等于）
	- != （不等于）

说明：

- 关系运算符的优先级低于算数运算符
- 关系运算符的优先级高于赋值运算符

#### ==逻辑运算==

- 逻辑变量之间的运算称为逻辑运算。二进制数1和0在逻辑上可以表达“真”和“假”。

**逻辑运算**

- 逻辑或（||、+、U、V、OR）：连接的两个逻辑值全0时才取0
- 逻辑与（&&、`*`、·、∩、∧、AND）：连接的两个逻辑值全1时才取1
- 逻辑异或（⊕、XOR）：连接的两个逻辑值相同时才取1，相同则取0
- 逻辑非（！、¬、~、NOT,-）：将原逻辑值取反即可

**真值表**

- 描述一个逻辑表达式与其变量之间的关系

|  A  |  B  | !A  | A+B | `A*B` | A⊕B |
| :-: | :-: | :-: | :-: | :---: | :-: |
|  0  |  0  |  1  |  0  |   0   |  0  |
|  0  |  1  |  1  |  1  |   0   |  1  |
|  1  |  1  |  0  |  1  |   0   |  1  |
|  1  |  1  |  0  |  1  |   1   |  0  |

**逻辑运算符**

- && （逻辑与）相当于其他语言中的AND
- || （逻辑或）相当于其他语言中的OR
- !（逻辑非）相当于其他语言中的NOT

例：

- a&&b 若a，b为真，则a&&b为真。
- a||b 若a，b之一为真，则a||b为真。
- !a 若a为真，则!a为假。

优先次序：

- !（非）-> &&（与）->||（或）
- 逻辑运算符中的“&&”和“||”低于关系运算符，“!”高于算术运算符
- 因此运算符的优先顺序：!>算数运算符>关系运算符>&&>||>赋值运算符

#### ==短路原则==

在逻辑表达式的求解中，并不是所有的逻辑运算符都要被执行。

1. a&&b&&c 只要a为真时，才需要判断b的值，只有a和b都为真时，才需要判断c的值
2. a||b||c 只要a为真，就不必判断b和c的值，只有a为假，才判断b。a和b都为假才判断c

::: tip 例如
(m=a>b)&&(n=c>d)

当a=1，b=2，c=3，d=4，m和n的原值为1时，由于“a>b”的值为0，因此m=0，而n=c>d不被执行，因此n的值不是0而仍保持原值1。
:::

#### 例题

::: tip 例题1
要判断字长为16位的整数a的低四位是否全为0，则（）。
- A、将a与0x000F进行"逻辑与"运算，然后判断运算结果是否等于0
- B、将a与0x000F进行"逻辑或"运算，然后判断运算结果是否等于F
- C、将a与0x000F进行"逻辑异或"运算，然后判断运算结果是否等于0
- D、将a与0x000F进行"逻辑与"运算，然后判断运算结果是否等于F
:::

- 0x000F的用二进制表示为：0000 0000 0000 1111
	- 若a的底四位结果都为0，进行逻辑与运算，其结果就为0。
	- 若a的底四位结果都为1，进行逻辑或运算，其结果也为1，等于F，无法判断。
	- 当a的低四位结果都为1，进行逻辑异或运算，其结果才为0，C选项错误。
	- 当a的低四位结果都为1，进行逻辑与运算，其结果才为F，D选项错误。
- 故正确答案为**A**

::: tip 例题2
对布尔表达式进行短路求值是指：无须对表达式中所有操作数或运算符进行计算就可确定表达式的值。对于表达式"aor(c<d)andb)”,（）时可进行短路计算。
- A、d为true
- B、a为true
- C、b为true
- D、c为true
:::



